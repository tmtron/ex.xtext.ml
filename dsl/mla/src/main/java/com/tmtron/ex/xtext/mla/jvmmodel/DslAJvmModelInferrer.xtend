/*
 * generated by Xtext 2.13.0
 */
package com.tmtron.ex.xtext.mla.jvmmodel

import com.google.inject.Inject
import com.tmtron.ex.xtext.mla.dslA.DefinitionA
import com.tmtron.ex.xtext.mla.dslA.ModelA
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder
import org.eclipse.xtext.common.types.JvmVisibility

/**
 * <p>Infers a JVM model from the source model.</p> 
 *
 * <p>The JVM model should contain all elements that would appear in the Java code 
 * which is generated from the source model. Other models link against the JVM model rather than the source model.</p>     
 */
class DslAJvmModelInferrer extends AbstractModelInferrer {

	/**
	 * convenience API to build and initialize JVM types and their members.
	 */
	@Inject extension JvmTypesBuilder jvmTypesBuilder

	def dispatch void infer(ModelA model, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		println(this.class.simpleName+' isPreIndexingPhase='+isPreIndexingPhase)
		
		val package = if (model.name !== null) model.name + '.' else ''
		val classname = package + 'ModelA'
		
		acceptor.accept(model.toClass(classname)) [
			model.definitionsA.forEach[definition |
				members += DslAJvmModelInferrer.getField(definition, jvmTypesBuilder)	 
			]
		]
	}
	
	def static getField(DefinitionA definition, extension JvmTypesBuilder jvmTypesBuilder) {
		definition.toField(definition.name, definition.fieldType) [
			visibility = JvmVisibility.PUBLIC
			static = true
		]		
	}
}
